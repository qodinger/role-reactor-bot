---
description: test
alwaysApply: false
---
  },
];
```

### Mock Objects

Create realistic mock objects that match Discord.js patterns:

```javascript
const mockGuild = {
  id: "123456789012345678",
  name: "Test Guild",
  roles: {
    cache: new Map([
      ["role1", { id: "role1", name: "Developer", color: "#FF0000" }],
    ]),
  },
  members: {
    cache: new Map([
      ["member1", { id: "member1", user: { username: "TestUser" } }],
    ]),
  },
};
```

## 6. Test Lifecycle Management

### Setup and Teardown

```javascript
describe("Test Suite", () => {
  let mockData;

  beforeAll(() => {
    // One-time setup for the entire test suite
    mockData = createMockData();
  });

  beforeEach(() => {
    // Setup before each test
    jest.clearAllMocks();
  });

  afterEach(() => {
    // Cleanup after each test
    jest.clearAllMocks();
  });

  afterAll(() => {
    // Cleanup after all tests
    jest.clearAllTimers();
    if (global.gc) {
      global.gc();
    }
  });
});
```

### Memory Management

- Always clear mocks between tests
- Use `jest.clearAllTimers()` for timer cleanup
- Force garbage collection if available
- Use `timer.unref()` for timers that shouldn't keep the process alive

## 7. Assertion Patterns

### Basic Assertions

```javascript
// Equality
expect(result).toBe(expected);
expect(result).toEqual(expected);

// Type checking
expect(result).toBeInstanceOf(Date);
expect(typeof result).toBe("string");

// Array/Collection assertions
expect(array).toHaveLength(3);
expect(array).toContain(item);
expect(array).toEqual(expect.arrayContaining([item1, item2]));

// Object assertions
expect(object).toHaveProperty("key");
expect(object).toMatchObject({ key: "value" });
```

### Async Testing

```javascript
// Promise resolution
await expect(asyncFunction()).resolves.toBe(expected);

// Promise rejection
await expect(asyncFunction()).rejects.toThrow("Error message");

// Async/await pattern
test("should handle async operations", async () => {
  const result = await asyncFunction();
  expect(result).toBe(expected);
});
```

## 8. Error Handling Tests

### Error Scenarios

Always test error conditions and edge cases:

```javascript
test("should handle invalid input gracefully", () => {
  expect(() => {
    functionWithValidation("invalid input");
  }).toThrow("Invalid input provided");
});

test("should return null for invalid data", () => {
  const result = parseFunction("invalid");
  expect(result).toBeNull();
});
```

### Network/API Errors

```javascript
test("should handle API errors gracefully", async () => {
  const error = new Error("API Error");
  error.code = 500;

  jest.spyOn(apiClient, "request").mockRejectedValue(error);

  const result = await functionThatCallsAPI();
  expect(result).toBeNull();
});
```

## 9. Performance Testing

### Timing Assertions

```javascript
test("should complete within acceptable time", async () => {
  const startTime = Date.now();

  await performOperation();

  const duration = Date.now() - startTime;
  expect(duration).toBeLessThan(1000); // Less than 1 second
});
```

### Memory Usage

```javascript
test("should not leak memory", () => {
  const initialMemory = process.memoryUsage().heapUsed;

  // Perform operations that might leak memory

  const finalMemory = process.memoryUsage().heapUsed;
  expect(finalMemory - initialMemory).toBeLessThan(1024 * 1024); // Less than 1MB
});
```

## 10. Integration Test Patterns

### Database Integration

```javascript
describe("Database Integration", () => {
  test("should save and retrieve data", async () => {
    const testData = { id: "test", value: "data" };

    await saveData(testData);
    const retrieved = await getData("test");

    expect(retrieved).toEqual(testData);
  });
});
```

### API Integration

```javascript
describe("Discord API Integration", () => {
  test("should handle role assignment", async () => {
    const mockMember = createMockMember();
    const mockRole = createMockRole();

    const result = await assignRole(mockMember, mockRole);

    expect(result).toBe(true);
    expect(mockMember.roles.add).toHaveBeenCalledWith(mockRole);
  });
});
```

## 11. E2E Test Patterns

### Workflow Testing

```javascript
describe("Role Management Workflow", () => {
  test("should complete full role assignment workflow", async () => {
    // 1. Setup
    const guild = createMockGuild();
    const member = createMockMember();
    const role = createMockRole();

    // 2. Execute workflow
    await setupRoleChannel(guild);
    await createRoleMessage(guild, role);
    await assignRoleToMember(member, role);

    // 3. Verify results
    expect(member.roles.has(role.id)).toBe(true);
    expect(guild.channels.cache.has("role-channel")).toBe(true);
  });
});
```

## 12. Common Anti-patterns to Avoid

### âŒ Don't Do This

```javascript
// Hardcoded environment variables
process.env.DISCORD_TOKEN = "test-token";

// Complex module mocks that import other modules
jest.mock("../../src/config/config.js", () => ({
  // Complex mock that imports other modules
}));

// Vague test names
test("works", () => {
  expect(true).toBe(true);
});

// Missing cleanup
test("creates timers", () => {
  setTimeout(() => {}, 1000);
  // Timer not cleaned up
});
```

### âœ… Do This Instead

```javascript
// Use setup file for environment variables
// Environment variables are set in tests/setup.js

// Simple, focused mocks
jest.mock("../../src/utils/logger.js", () => ({
  getLogger: () => ({ info: jest.fn() }),
}));

// Descriptive test names
test("should parse role string with emoji and name", () => {
  const result = parseRoleString("ðŸ’» Coder");
  expect(result).toEqual([{ emoji: "ðŸ’»", roleName: "Coder" }]);
});

// Proper cleanup
afterEach(() => {
  jest.clearAllTimers();
});
```

## 13. Test Coverage Guidelines

### What to Test

- **Unit Tests**: Individual functions, edge cases, error conditions
- **Integration Tests**: Module interactions, database operations, API calls
- **E2E Tests**: Complete user workflows, critical business logic

### Coverage Targets

- **Unit Tests**: 90%+ line coverage for utility functions
- **Integration Tests**: Cover all major module interactions
- **E2E Tests**: Cover critical user workflows

### Test Categories

- **Happy Path**: Normal operation with valid inputs
- **Edge Cases**: Boundary conditions, empty inputs, maximum values
- **Error Cases**: Invalid inputs, network failures, permission errors
- **Performance**: Response times, memory usage, resource cleanup

## 14. Debugging and Maintenance

### Test Debugging

- Use descriptive test names and descriptions
- Add console.log statements temporarily for debugging
- Use Jest's `--verbose` flag for detailed output
- Use `--detectOpenHandles` to find memory leaks

### Test Maintenance

- Keep tests simple and focused
- Update tests when changing implementation
- Remove obsolete tests
- Refactor tests when they become complex

### Documentation

- Add JSDoc comments for complex test utilities
- Document test data structures
- Explain complex test scenarios
- Keep test README updated

## 15. Best Practices Summary

1. **Use the setup file** for environment variables
2. **Minimize mocking** to avoid module resolution issues
3. **Use dynamic imports** for problematic modules
4. **Write descriptive test names** that explain the expected behavior
5. **Test both success and failure scenarios**
6. **Clean up resources** properly in afterEach/afterAll
7. **Use realistic test data** that matches production patterns
8. **Group related tests** logically with describe blocks
9. **Avoid complex mocks** that import other modules
10. **Follow the established patterns** from existing test files

This rule ensures consistent, maintainable, and reliable test coverage across the entire Role Reactor Discord Bot project.
